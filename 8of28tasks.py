#1. Поизучайте устройство криптографических хэш-функций: принципы, лежащие в основе стандартов SHA-256 или MD5.

#2. Поизучайте, как создаётся хэш-функция, оптимизированная для распределённой базы данных или распределённого кэша (Consistent Hashing).

#3.* Реализуйте динамическую хэш-таблицу, которая автоматически удваивает свой размер, если уровень заполненности превышает заданный порог (например, 75%).
#Реализация должна корректно перераспределять все элементы в новую, более крупную хэш-таблицу с минимальными затратами по времени.

#4.* Реализуйте хэш-таблицу, которая использует несколько хэш-функций для каждой операции вставки, чтобы уменьшить вероятность коллизий. Проанализируйте, как это влияет на производительность и вероятность коллизий.

#5.* Организуйте ddos-атаку на вашу исходную хэш-таблицу -- с помощью специально сгенерированных ключей, вызывающих большое число коллизий. Затем модифицируйте хэш-таблицу для защиты от таких атак (например, посолите). 

class HashTable:
    def __init__(self, sz, stp):
        self.size = sz
        self.step = stp
        self.slots = [None] * self.size

     def hash_fun(self, value):
         # в качестве value поступают строки!

         # всегда возвращает корректный индекс слота
         return 0

     def seek_slot(self, value):
         # находит индекс пустого слота для значения, или None
         return None

     def put(self, value):
         # записываем значение по хэш-функции
         
         # возвращается индекс слота или None,
         # если из-за коллизий элемент не удаётся
         # разместить 
         return None

     def find(self, value):
         # находит индекс слота со значением, или None
         return None
