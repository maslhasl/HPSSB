#4. Стек

class Stack:
    def __init__(self):
        self.stack = []
        self.count = 0 #пока под вопросом

#1. Подберите подходящую динамическую структуру данных для хранения стека. Реализуйте методы size(), pop(), push() и peek().
#Добавьте тесты для каждого из этих четырёх методов.
#Оцените меру сложности для операций pop и push. 

#Я хочу реализовать стек, через динамический массив. Хочу это сделать, тк мне интересно поработать с resize массива и соответственно стека.
#Также используя счетчик при добавлении новых элементов в стек, 
#можно отслеживать размер стека и в методе size обращаться просто к этому значению - соответственно переменную счетчика надо добавить в метод самого стека.
#Логично что начем мы с пустого стека и значения count = 0 == size = 0
#Пока мне неясно как обращаться к верхушке стека (хвосту массива) как к дну стека (голове массива) - еслия верно понял вопрос.
    
    def size(self):
        return len(self.stack)

    def pop(self):
        # ваш код
        return None # если стек пустой

    def push(self, value):
        # ваш код

    def peek(self):
        # ваш код
        return None # если стек пустой

#2. Переделайте реализацию стека так, чтобы она работала не с хвостом списка как с верхушкой стека, а с его головой. 


#3. Не запуская программу, скажите, как отработает такой цикл? 
while stack.size() > 0:
    print(stack.pop())
    print(stack.pop())

#4. Оцените меру сложности для операций pop и push. 


######################
stack = Stack()
stack.push(1)
stack.push("2")
stack.push(3.14)
while stack.size() > 0:
    stack.pop()
